{% extends 'base.html' %}

{% load static %}

{% block content %}
  <!-- header -->
  <a href='/signup'>Signup</a>
  <a href='/login'>Login</a>
  {% if user.is_authenticated %}
    Hello, {{ user.get_username }}!
  {% endif %}
  <br>
  <!-- canvas -->
  <div style='background-color: grey; display: inline-flex; margin-top: 3px'>
    <canvas id='canvas' width=800 height=600 style='margin: 3px'>
      <p>Your browser does not support the canvas element.</p>
    </canvas>
  </div>
  <br>
  <!-- controls -->
  <div id='app'>
    <div style='float:left; padding-right:2em'>
      <h2>gardens</h2>
      <input v-for='garden in gardens' type='button' :value='garden.name' @click='gardenId = garden.id; gardenDetails()'><br>
      <h3>create</h3>
      <input type='text' v-model='gardenCreateName' placeholder='name'><br>
      <input type='button' value='create' @click='gardenCreate()'>
      <h2>visual mode</h2>
      <input type='radio' id='sel'  value='sel'  v-model='visualMode'><label for='sel' >select          </label><br>
      <input type='radio' id='ref'  value='ref'  v-model='visualMode'><label for='ref' >create reference</label><br>
      <input type='radio' id='ctx'  value='ctx'  v-model='visualMode'><label for='ctx' >create context  </label><br>
      <input type='radio' id='plnt' value='plnt' v-model='visualMode'><label for='plnt'>create plant    </label><br>
    </div>
    <div style='float:left; padding-right:2em'>
      <h2>references</h2>
      <table v-if='references.length'>
        <tr>
          <th></th>
          <th>1</th>
          <th>2</th>
        </tr>
        <tr v-for='reference in references'>
          <td>v{ reference.name }v (v{ reference.x }v, v{ reference.y }v)</td>
          <td><input type='radio' :value='reference.id' v-model='reference1'></td>
          <td><input type='radio' :value='reference.id' v-model='reference2'></td>
        </tr>
      </table>
      <h3>prefer</h3>
      <input type='radio' id='n' value='n' v-model='referencePrefer'><label for='n'>north</label>
      <input type='radio' id='e' value='e' v-model='referencePrefer'><label for='e'>east </label><br>
      <input type='radio' id='s' value='s' v-model='referencePrefer'><label for='s'>south</label>
      <input type='radio' id='w' value='w' v-model='referencePrefer'><label for='w'>west </label><br>
      <h3>create</h3>
      <input type='text' v-model='referenceCreateName' placeholder='name'><br>
      <input type='number' v-model.number='referenceCreateX'>x<br>
      <input type='number' v-model.number='referenceCreateY'>y<br>
      <input type='button' value='create' @click='referenceCreate()'>
      <h2>location</h2>
      <input type='number' v-model.number='locationD1' placeholder='distance from reference 1'>R1<br>
      <input type='number' v-model.number='locationD2' placeholder='distance from reference 2'>R2<br>
    </div>
    <div style='float:left; padding-right:2em'>
      <h2>plants</h2>
      <input type='text' v-model='plantObserveName' placeholder='name'><br>
      <input type='number' v-model.number='plantObserveX'>x<br>
      <input type='number' v-model.number='plantObserveY'>y<br>
      <input type='button' value='observe' @click='plantObserve()'>
      <h3>icon</h3>
      <input type='text' v-model='plantObserveIconParamsCopyFrom' placeholder='plant name'><input type='button' value='copy' @click='iconParamsCopy'><br>
      <input type='number' v-model.number='plantObserveIconParams.root.seed' @change='iconParamsChanged'>seed<br>
      <div v-for='v, k in plantObserveIconParams'>
        <h4>v{ k }v</h4>
        <input type='number' @change='iconParamsChanged' v-model.number='v.size'>size<br>
        <input type='number' @change='iconParamsChanged' v-model.number='v.segments'>segments<br>
        <input type='number' @change='iconParamsChanged' v-model.number='v.split.number'>split-number<br>
        <input type='number' @change='iconParamsChanged' v-model.number='v.split.angle.start'>split-angle-start<br>
        <input type='number' @change='iconParamsChanged' v-model.number='v.split.angle.step'>split-angle-step<br>
        <input type='number' @change='iconParamsChanged' v-model.number='v.split.angle.variance'>split-angle-variance<br>
        <input type='number' @change='iconParamsChanged' v-model.number='v.width'>width<br>
        <input type='number' @change='iconParamsChanged' v-model.number='v.corrugation.amplitude'>corrugation-amplitude<br>
        <input type='number' @change='iconParamsChanged' v-model.number='v.corrugation.number'>corrugation-number<br>
        <input type='button' value='add child' @click='iconParamsAddChild(k)'>
        <input type='button' value='remove' @click='iconParamsRemoveChild(k)' v-if='k!="root"'>
      </div>
    </div>
  </div>
  {% csrf_token %}
  <!-- script -->
  {% if debug %}
    <script src='https://cdn.jsdelivr.net/npm/vue/dist/vue.js'></script>
  {% else %}
    <script src='https://cdn.jsdelivr.net/npm/vue'></script>
  {% endif %}
  <script type='module'>

import {
  listenToTouches,
} from '{% static 'obvious.js' %}'

const CSRF_TOKEN = document.getElementsByName('csrfmiddlewaretoken')[0].value;
const CANVAS = document.getElementById('canvas');
const CONTEXT = CANVAS.getContext('2d');

class Rand {
  constructor(seed) {
    this.state = seed;
  }
  next(min = 0, max = 1) {
    this.state ^= this.state << 13;
    this.state ^= this.state >> 17;
    this.state ^= this.state << 5;
    const e30 = 1 << 30;
    return ((this.state + 2 * e30) / (4 * e30) * (max - min)) + min;
  }
}

function constructIconParams(seed = false) {
  const result = {
    size: 0.02,
    segments: 2,
    split: {
      number: 2,
      angle: {
        start: -0.2,
        step: 0.4,
        variance: 0.1,
      },
    },
    width: 0,
    corrugation: {
      amplitude: 0,
      number: 2,
    },
  };
  if (seed) result['seed'] = 1;
  return result;
}

var app = new Vue({
  el: '#app',
  delimiters: ['v{', '}v'],
  data: () => ({
    'gardenCreateName': '',
    'gardens': [],
    'gardenId': null,
    'visualMode': 'sel',
    'referenceCreateName': '',
    'referenceCreateX': '',
    'referenceCreateY': '',
    'references': [],
    'reference1': null,
    'reference2': null,
    'referencePrefer': 'n',
    'locationD1': '',
    'locationD2': '',
    'plantObserveName': '',
    'plantObserveX': '',
    'plantObserveY': '',
    'plantObserveIconParamsCopyFrom': '',
    'plantObserveIconParams': {'root': constructIconParams(true)},
    'plants': [],
    'x': 0,
    'y': 0,
    'zoom': 1, // zoom = pixels / observation_units
  }),
  methods: {
    post(url, body) {
      return fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': CSRF_TOKEN,
        },
        body: JSON.stringify(body),
      });
    },
    // math
    transformToPixels(point) {
      const s = {
        x:  (point.x - this.x) * this.zoom + CANVAS.width  / 2,
        y: -(point.y - this.y) * this.zoom + CANVAS.height / 2,
      };
      s.px = s.x;
      s.py = s.y;
      return s;
    },
    transformToWorld(point) {
      const s = {
        x:  (point.x - CANVAS.width  / 2) / this.zoom + this.x,
        y: -(point.y - CANVAS.height / 2) / this.zoom + this.y,
      };
      s.wx = s.x;
      s.wy = s.y;
      return s;
    },
    distance(xi, yi, xf, yf) {
      return Math.sqrt(Math.pow(xf - xi, 2) + Math.pow(yf - yi, 2));
    },
    plantObservation(plant) {
      return plant.observations[plant.observations.length - 1];
    },
    calculateXY() {
      var r1, r2;
      for (const i of this.references) {
        if (i.id == this.reference1) r1 = { x: i.x, y: i.y };
        if (i.id == this.reference2) r2 = { x: i.x, y: i.y };
      }
      if (!r1 || !r2) {
        alert('references not selected');
        return;
      }
      const d1 = this.locationD1;
      const d2 = this.locationD2;
      // create a new coordinate system (p, q) with r1 at origin and r2 and (d, 0)
      const d = this.distance(r1.x, r1.y, r2.x, r2.y);
      const i = {};
      i.p = (Math.pow(d, 2) - Math.pow(d2, 2) + Math.pow(d1, 2)) / (2 * d);
      i.q = Math.sqrt(Math.pow(d1, 2) - Math.pow(i.p, 2));
      // transform back to (x, y)
      const a = {
        x: r1.x + (r2.x - r1.x) / d * i.p + (r2.y - r1.y) / d * i.q,
        y: r1.y + (r2.y - r1.y) / d * i.p + (r2.x - r1.x) / d * i.q,
      };
      const b = {
        x: r1.x + (r2.x - r1.x) / d * i.p - (r2.y - r1.y) / d * i.q,
        y: r1.y + (r2.y - r1.y) / d * i.p - (r2.x - r1.x) / d * i.q,
      };
      // select preferred
      var result;
      if (this.referencePrefer == 'n') result = a.y > b.y ? a : b;
      if (this.referencePrefer == 'e') result = a.x > b.x ? a : b;
      if (this.referencePrefer == 's') result = a.y < b.y ? a : b;
      if (this.referencePrefer == 'w') result = a.x < b.x ? a : b;
      this.referenceCreateX = result.x;
      this.referenceCreateY = result.y;
      this.plantObserveX = result.x;
      this.plantObserveY = result.y;
    },
    // rendering
    renderSegment(x, y, angle, params, rand, split) {
      const angleF = angle + 2 * Math.PI * (
        + params.split.angle.start
        + split * params.split.angle.step
        + params.split.angle.variance * rand.next(-1, 1)
      );
      const xf = x + params.size * Math.sin(angleF);
      const yf = y + params.size * Math.cos(angleF);
      const d = this.distance(x, y, xf, yf);
      const w = {
        x: -(yf - y) / d * params.width,
        y:  (xf - x) / d * params.width,
      };
      const divisions = params.corrugation.number * 5;
      CONTEXT.fillStyle = 'white';
      CONTEXT.beginPath();
      {
        const { px, py } = this.transformToPixels({ x, y });
        CONTEXT.moveTo(px, py);
      }
      for (var i = 0; i < divisions; ++i) {
        const theta = (i / (divisions - 1)) * 2 * Math.PI;
        const p = (1 - Math.cos(theta)) / 2;
        const q = (    Math.sin(theta)) / 2;
        const s = 1 + params.corrugation.amplitude * Math.cos(params.corrugation.number * theta);
        const { px, py } = this.transformToPixels({
          x: x + (p * (xf - x) + q * w.x) * s,
          y: y + (p * (yf - y) + q * w.y) * s,
        });
        CONTEXT.lineTo(px, py);
      }
      CONTEXT.stroke();
      CONTEXT.fill();
      return { x: xf, y: yf, angle: angleF };
    },
    renderIcon(x, y, params) {
      const rand = new Rand(params.seed);
      const work = [{ x, y, angle: 0, generation: 1, params }];
      while (work.length) {
        const segment = work.pop();
        for (var split = 0; split < segment.params.split.number; ++split) {
          const { x, y, angle } = this.renderSegment(segment.x, segment.y, segment.angle, segment.params, rand, split);
          if (segment.generation < segment.params.segments)
            work.push({ x, y, angle, generation: segment.generation + 1, params: segment.params });
          const children = segment.params.children;
          for (const k in children)
            work.push({ x, y, angle, generation: 1, params: children[k]});
        }
      }
    },
    render() {
      CONTEXT.fillStyle = 'white';
      CONTEXT.fillRect(0, 0, CANVAS.width, CANVAS.height);
      // references
      for (const i of this.references) {
        const { px, py } = this.transformToPixels(i);
        CONTEXT.beginPath();
        CONTEXT.arc(px, py, 4, 0, 2 * Math.PI);
        CONTEXT.stroke();
      }
      // context
      for (const i of this.context) {
        switch (i.instructions.op) {
          case 'lines':
            CONTEXT.beginPath();
            var f = CONTEXT.moveTo.bind(CONTEXT);
            for (const j of i.instructions.points){
              const p = this.transformToPixels(j);
              f(p.x, p.y);
              f = CONTEXT.lineTo.bind(CONTEXT);
            }
            CONTEXT.stroke();
            break;
        }
      }
      // plants
      for (const i of this.plants) {
        var { x, y, icon_params } = this.plantObservation(i);
        if (i.name == this.plantObserveName)
          icon_params = this.iconParamsNest(this.plantObserveIconParams);
        const { px, py } = this.transformToPixels({x, y});
        CONTEXT.beginPath();
        CONTEXT.arc(px, py, 4, 0, Math.PI);
        CONTEXT.stroke();
        this.renderIcon(x, y, icon_params);
      }
    },
    // events
    onEnd(id, x, y) {
      const world = this.transformToWorld({ x, y });
      const round = {
        x: Math.round(world.x * 1000) / 1000,
        y: Math.round(world.y * 1000) / 1000,
      };
      switch (this.visualMode) {
        case 'sel':
          for (const plant of this.plants) {
            const observation = this.plantObservation(plant);
            const location = this.transformToPixels(observation);
            if (this.distance(location.px, location.py, x, y) < 10) {
              this.plantObserveName = plant.name;
              this.plantObserveX = world.x;
              this.plantObserveY = world.y;
              this.plantObserveIconParams = this.iconParamsFlatten(observation.icon_params);
              return;
            }
          }
          break;
        case 'ref':
          if (!this.referenceCreateName) return;
          this.referenceCreateX = round.x;
          this.referenceCreateY = round.y;
          this.referenceCreate();
          break;
        case 'ctx':
          if (!this.contextI) {
            this.contextI = round;
          } else {
            this.post('/context_create', {
              garden: this.gardenId,
              instructions: JSON.stringify({
                op: 'lines',
                points: [this.contextI, round],
              }),
            }).then(this.gardenDetails);
            this.contextI = null;
          }
          break;
        case 'plnt':
          if (!this.plantObserveName) return;
          this.plantObserveX = round.x;
          this.plantObserveY = round.y;
          this.plantObserve();
          break;
      }
    },
    // icon params
    iconParamsFlatten(params) {
      function recurse(params, path = 'root') {
        var result = { [path]: params };
        for (const i in params.children)
          result = { ...result, ...recurse(params.children[i], path + '.' + i) };
        return result;
      }
      const result = JSON.parse(JSON.stringify(recurse(params)));
      for (const k in result) delete result[k].children;
      return result;
    },
    iconParamsNest(params) {
      const keys = Object.keys(params).sort();
      const result = { ...params['root'], children: {} };
      for (const i of keys.slice(1)) {
        var node = result;
        const split = i.split('.');
        const leaf = split.pop();
        for (const j of split.slice(1)) node = node.children[j];
        node.children[leaf] = { ...params[i], children: {} };
      }
      return JSON.parse(JSON.stringify(result));
    },
    iconParamsAddChild(parent) {
      const child = parent + '.' + Object.keys(this.plantObserveIconParams).length;
      this.$set(this.plantObserveIconParams, child, constructIconParams());
      this.iconParamsChanged();
    },
    iconParamsRemoveChild(k) {
      this.$delete(this.plantObserveIconParams, k);
      this.iconParamsChanged();
    },
    iconParamsChanged() {
      this.render();
    },
    iconParamsCopy() {
      for (const i of this.plants)
        if (i.name == this.plantObserveIconParamsCopyFrom) {
          const observation = this.plantObservation(i);
          this.plantObserveIconParams = this.iconParamsFlatten(observation.icon_params);
          break;
        }
      this.plantObserveIconParams.root.seed = Math.floor(Math.random() * (1 << 24));
      this.iconParamsChanged();
    },
    // API
    async gardenList() {
      this.gardens = await fetch('/garden_retrieve').then(r => r.json()).then(j => j.items);
    },
    gardenCreate() {
      this.post('/garden_create', { name: this.gardenCreateName }).then(this.gardenList);
    },
    async gardenDetails() {
      const { references, context, plants } = await fetch(`/garden_details?id=${this.gardenId}`).then(r => r.json());
      this.references = references;
      this.context = context;
      this.plants = plants;
      if (references.length || plants.length) {
        // get extent of garden
        var entities = references;
        for (const plant of plants) entities = entities.concat(plant.observations);
        var xi, yi, xf, yf;
        for (const i of entities) {
          if (xi == undefined || i.x < xi) xi = i.x;
          if (yi == undefined || i.y < yi) yi = i.y;
          if (xf == undefined || i.x > xf) xf = i.x;
          if (yf == undefined || i.y > yf) yf = i.y;
        }
        // center and zoom
        this.x = (xi + xf) / 2;
        this.y = (yi + yf) / 2;
        this.zoom = Math.min(CANVAS.width / (xf - xi), CANVAS.height / (yf - yi)) * 0.8;
        if (this.zoom == 0 || this.zoom == Infinity) this.zoom = 1;
      }
      // render
      this.render();
    },
    referenceCreate() {
      this.post('/reference_create', {
        garden: this.gardenId,
        name: this.referenceCreateName,
        x: this.referenceCreateX,
        y: this.referenceCreateY,
      }).then(this.gardenDetails);
    },
    async plantObserve() {
      // gather observation from user
      var location;
      if (this.plantObserveX != '' && this.plantObserveY != '')
        location = { x: this.plantObserveX, y: this.plantObserveY };
      var iconParams = this.iconParamsNest(this.plantObserveIconParams);
      // ensure plant exists
      var plantId = null;
      for (const i of this.plants)
        if (i.name == this.plantObserveName) {
          plantId = i.id;
          if (location == undefined) location = this.plantObservation(i);
          break;
        }
      if (!plantId) plantId = await this.post('/plant_create', {
        garden: this.gardenId,
        name: this.plantObserveName,
      }).then(r => r.json()).then(j => j.id);
      // observe
      await this.post('/observation_create', {
        plant: plantId,
        x: location.x,
        y: location.y,
        notes: '',
        icon_params: JSON.stringify(iconParams),
        gone: false,
      });
      // update
      this.gardenDetails();
    },
  },
  watch: {
    plantObserveName() {
      this.render();
    },
    locationD1() {
      this.calculateXY();
    },
    locationD2() {
      this.calculateXY();
    },
  },
  mounted() {
    this.gardenList();
  },
});

listenToTouches(CANVAS, {
  onEnd: app.onEnd,
});

CONTEXT.fillStyle = 'white';
CONTEXT.fillRect(0, 0, CANVAS.width, CANVAS.height);

  </script>
{% endblock %}
